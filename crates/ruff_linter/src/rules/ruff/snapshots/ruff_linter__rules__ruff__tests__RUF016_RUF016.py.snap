---
source: crates/ruff_linter/src/rules/ruff/mod.rs
---
RUF016 Indexed access to type `str` uses type `str` instead of an integer or slice
  --> RUF016.py:22:13
   |
21 | # Should emit for invalid access on strings
22 | var = "abc"["x"]
   |             ^^^
23 | var = f"abc"["x"]
   |

RUF016 Indexed access to type `str` uses type `str` instead of an integer or slice
  --> RUF016.py:23:14
   |
21 | # Should emit for invalid access on strings
22 | var = "abc"["x"]
23 | var = f"abc"["x"]
   |              ^^^
24 |
25 | # Should emit for invalid access on bytes
   |

RUF016 Indexed access to type `bytes` uses type `str` instead of an integer or slice
  --> RUF016.py:26:14
   |
25 | # Should emit for invalid access on bytes
26 | var = b"abc"["x"]
   |              ^^^
27 |
28 | # Should emit for invalid access on lists and tuples
   |

RUF016 Indexed access to type `list` uses type `str` instead of an integer or slice
  --> RUF016.py:29:17
   |
28 | # Should emit for invalid access on lists and tuples
29 | var = [1, 2, 3]["x"]
   |                 ^^^
30 | var = (1, 2, 3)["x"]
   |

RUF016 Indexed access to type `tuple` uses type `str` instead of an integer or slice
  --> RUF016.py:30:17
   |
28 | # Should emit for invalid access on lists and tuples
29 | var = [1, 2, 3]["x"]
30 | var = (1, 2, 3)["x"]
   |                 ^^^
31 |
32 | # Should emit for invalid access on list comprehensions
   |

RUF016 Indexed access to type `list comprehension` uses type `str` instead of an integer or slice
  --> RUF016.py:33:30
   |
32 | # Should emit for invalid access on list comprehensions
33 | var = [x for x in range(10)]["x"]
   |                              ^^^
34 |
35 | # Should emit for invalid access using tuple
   |

RUF016 Indexed access to type `str` uses type `tuple` instead of an integer or slice
  --> RUF016.py:36:13
   |
35 | # Should emit for invalid access using tuple
36 | var = "abc"[1, 2]
   |             ^^^^
37 |
38 | # Should emit for invalid access using string
   |

RUF016 Indexed access to type `list` uses type `str` instead of an integer or slice
  --> RUF016.py:39:14
   |
38 | # Should emit for invalid access using string
39 | var = [1, 2]["x"]
   |              ^^^
40 | var = [1, 2][t"x"]
   |

RUF016 Indexed access to type `list` uses type `str` instead of an integer or slice
  --> RUF016.py:40:14
   |
38 | # Should emit for invalid access using string
39 | var = [1, 2]["x"]
40 | var = [1, 2][t"x"]
   |              ^^^^
41 |
42 | # Should emit for invalid access using float
   |

RUF016 Indexed access to type `list` uses type `float` instead of an integer or slice
  --> RUF016.py:43:14
   |
42 | # Should emit for invalid access using float
43 | var = [1, 2][0.25]
   |              ^^^^
44 |
45 | # Should emit for invalid access using dict
   |

RUF016 Indexed access to type `list` uses type `dict` instead of an integer or slice
  --> RUF016.py:46:14
   |
45 | # Should emit for invalid access using dict
46 | var = [1, 2][{"x": "y"}]
   |              ^^^^^^^^^^
47 |
48 | # Should emit for invalid access using dict comp
   |

RUF016 Indexed access to type `list` uses type `dict comprehension` instead of an integer or slice
  --> RUF016.py:49:14
   |
48 | # Should emit for invalid access using dict comp
49 | var = [1, 2][{x: "y" for x in range(2)}]
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^
50 |
51 | # Should emit for invalid access using list 
   |

RUF016 Indexed access to type `list` uses type `tuple` instead of an integer or slice
  --> RUF016.py:52:14
   |
51 | # Should emit for invalid access using list 
52 | var = [1, 2][2, 3]
   |              ^^^^
53 |
54 | # Should emit for invalid access using list comp
   |

RUF016 Indexed access to type `list` uses type `list comprehension` instead of an integer or slice
  --> RUF016.py:55:14
   |
54 | # Should emit for invalid access using list comp
55 | var = [1, 2][[x for x in range(2)]]
   |              ^^^^^^^^^^^^^^^^^^^^^
56 |
57 | # Should emit on invalid access using set
   |

RUF016 Indexed access to type `list` uses type `set` instead of an integer or slice
  --> RUF016.py:58:14
   |
57 | # Should emit on invalid access using set
58 | var = [1, 2][{"x", "y"}]
   |              ^^^^^^^^^^
59 |
60 | # Should emit on invalid access using set comp
   |

RUF016 Indexed access to type `list` uses type `set comprehension` instead of an integer or slice
  --> RUF016.py:61:14
   |
60 | # Should emit on invalid access using set comp
61 | var = [1, 2][{x for x in range(2)}]
   |              ^^^^^^^^^^^^^^^^^^^^^
62 |
63 | # Should emit on invalid access using bytes
   |

RUF016 Indexed access to type `list` uses type `bytes` instead of an integer or slice
  --> RUF016.py:64:14
   |
63 | # Should emit on invalid access using bytes
64 | var = [1, 2][b"x"]
   |              ^^^^
65 |
66 | # Should emit for non-integer slice start
   |

RUF016 Slice in indexed access to type `list` uses type `str` instead of an integer
  --> RUF016.py:67:17
   |
66 | # Should emit for non-integer slice start
67 | var = [1, 2, 3]["x":2]
   |                 ^^^
68 | var = [1, 2, 3][f"x":2]
69 | var = [1, 2, 3][1.2:2]
   |

RUF016 Slice in indexed access to type `list` uses type `str` instead of an integer
  --> RUF016.py:68:17
   |
66 | # Should emit for non-integer slice start
67 | var = [1, 2, 3]["x":2]
68 | var = [1, 2, 3][f"x":2]
   |                 ^^^^
69 | var = [1, 2, 3][1.2:2]
70 | var = [1, 2, 3][{"x"}:2]
   |

RUF016 Slice in indexed access to type `list` uses type `float` instead of an integer
  --> RUF016.py:69:17
   |
67 | var = [1, 2, 3]["x":2]
68 | var = [1, 2, 3][f"x":2]
69 | var = [1, 2, 3][1.2:2]
   |                 ^^^
70 | var = [1, 2, 3][{"x"}:2]
71 | var = [1, 2, 3][{x for x in range(2)}:2]
   |

RUF016 Slice in indexed access to type `list` uses type `set` instead of an integer
  --> RUF016.py:70:17
   |
68 | var = [1, 2, 3][f"x":2]
69 | var = [1, 2, 3][1.2:2]
70 | var = [1, 2, 3][{"x"}:2]
   |                 ^^^^^
71 | var = [1, 2, 3][{x for x in range(2)}:2]
72 | var = [1, 2, 3][{"x": x for x in range(2)}:2]
   |

RUF016 Slice in indexed access to type `list` uses type `set comprehension` instead of an integer
  --> RUF016.py:71:17
   |
69 | var = [1, 2, 3][1.2:2]
70 | var = [1, 2, 3][{"x"}:2]
71 | var = [1, 2, 3][{x for x in range(2)}:2]
   |                 ^^^^^^^^^^^^^^^^^^^^^
72 | var = [1, 2, 3][{"x": x for x in range(2)}:2]
73 | var = [1, 2, 3][[x for x in range(2)]:2]
   |

RUF016 Slice in indexed access to type `list` uses type `dict comprehension` instead of an integer
  --> RUF016.py:72:17
   |
70 | var = [1, 2, 3][{"x"}:2]
71 | var = [1, 2, 3][{x for x in range(2)}:2]
72 | var = [1, 2, 3][{"x": x for x in range(2)}:2]
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^
73 | var = [1, 2, 3][[x for x in range(2)]:2]
   |

RUF016 Slice in indexed access to type `list` uses type `list comprehension` instead of an integer
  --> RUF016.py:73:17
   |
71 | var = [1, 2, 3][{x for x in range(2)}:2]
72 | var = [1, 2, 3][{"x": x for x in range(2)}:2]
73 | var = [1, 2, 3][[x for x in range(2)]:2]
   |                 ^^^^^^^^^^^^^^^^^^^^^
74 |
75 | # Should emit for non-integer slice end
   |

RUF016 Slice in indexed access to type `list` uses type `str` instead of an integer
  --> RUF016.py:76:19
   |
75 | # Should emit for non-integer slice end
76 | var = [1, 2, 3][0:"x"]
   |                   ^^^
77 | var = [1, 2, 3][0:f"x"]
78 | var = [1, 2, 3][0:1.2]
   |

RUF016 Slice in indexed access to type `list` uses type `str` instead of an integer
  --> RUF016.py:77:19
   |
75 | # Should emit for non-integer slice end
76 | var = [1, 2, 3][0:"x"]
77 | var = [1, 2, 3][0:f"x"]
   |                   ^^^^
78 | var = [1, 2, 3][0:1.2]
79 | var = [1, 2, 3][0:{"x"}]
   |

RUF016 Slice in indexed access to type `list` uses type `float` instead of an integer
  --> RUF016.py:78:19
   |
76 | var = [1, 2, 3][0:"x"]
77 | var = [1, 2, 3][0:f"x"]
78 | var = [1, 2, 3][0:1.2]
   |                   ^^^
79 | var = [1, 2, 3][0:{"x"}]
80 | var = [1, 2, 3][0:{x for x in range(2)}]
   |

RUF016 Slice in indexed access to type `list` uses type `set` instead of an integer
  --> RUF016.py:79:19
   |
77 | var = [1, 2, 3][0:f"x"]
78 | var = [1, 2, 3][0:1.2]
79 | var = [1, 2, 3][0:{"x"}]
   |                   ^^^^^
80 | var = [1, 2, 3][0:{x for x in range(2)}]
81 | var = [1, 2, 3][0:{"x": x for x in range(2)}]
   |

RUF016 Slice in indexed access to type `list` uses type `set comprehension` instead of an integer
  --> RUF016.py:80:19
   |
78 | var = [1, 2, 3][0:1.2]
79 | var = [1, 2, 3][0:{"x"}]
80 | var = [1, 2, 3][0:{x for x in range(2)}]
   |                   ^^^^^^^^^^^^^^^^^^^^^
81 | var = [1, 2, 3][0:{"x": x for x in range(2)}]
82 | var = [1, 2, 3][0:[x for x in range(2)]]
   |

RUF016 Slice in indexed access to type `list` uses type `dict comprehension` instead of an integer
  --> RUF016.py:81:19
   |
79 | var = [1, 2, 3][0:{"x"}]
80 | var = [1, 2, 3][0:{x for x in range(2)}]
81 | var = [1, 2, 3][0:{"x": x for x in range(2)}]
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^
82 | var = [1, 2, 3][0:[x for x in range(2)]]
   |

RUF016 Slice in indexed access to type `list` uses type `list comprehension` instead of an integer
  --> RUF016.py:82:19
   |
80 | var = [1, 2, 3][0:{x for x in range(2)}]
81 | var = [1, 2, 3][0:{"x": x for x in range(2)}]
82 | var = [1, 2, 3][0:[x for x in range(2)]]
   |                   ^^^^^^^^^^^^^^^^^^^^^
83 |
84 | # Should emit for non-integer slice step
   |

RUF016 Slice in indexed access to type `list` uses type `str` instead of an integer
  --> RUF016.py:85:21
   |
84 | # Should emit for non-integer slice step
85 | var = [1, 2, 3][0:1:"x"]
   |                     ^^^
86 | var = [1, 2, 3][0:1:f"x"]
87 | var = [1, 2, 3][0:1:1.2]
   |

RUF016 Slice in indexed access to type `list` uses type `str` instead of an integer
  --> RUF016.py:86:21
   |
84 | # Should emit for non-integer slice step
85 | var = [1, 2, 3][0:1:"x"]
86 | var = [1, 2, 3][0:1:f"x"]
   |                     ^^^^
87 | var = [1, 2, 3][0:1:1.2]
88 | var = [1, 2, 3][0:1:{"x"}]
   |

RUF016 Slice in indexed access to type `list` uses type `float` instead of an integer
  --> RUF016.py:87:21
   |
85 | var = [1, 2, 3][0:1:"x"]
86 | var = [1, 2, 3][0:1:f"x"]
87 | var = [1, 2, 3][0:1:1.2]
   |                     ^^^
88 | var = [1, 2, 3][0:1:{"x"}]
89 | var = [1, 2, 3][0:1:{x for x in range(2)}]
   |

RUF016 Slice in indexed access to type `list` uses type `set` instead of an integer
  --> RUF016.py:88:21
   |
86 | var = [1, 2, 3][0:1:f"x"]
87 | var = [1, 2, 3][0:1:1.2]
88 | var = [1, 2, 3][0:1:{"x"}]
   |                     ^^^^^
89 | var = [1, 2, 3][0:1:{x for x in range(2)}]
90 | var = [1, 2, 3][0:1:{"x": x for x in range(2)}]
   |

RUF016 Slice in indexed access to type `list` uses type `set comprehension` instead of an integer
  --> RUF016.py:89:21
   |
87 | var = [1, 2, 3][0:1:1.2]
88 | var = [1, 2, 3][0:1:{"x"}]
89 | var = [1, 2, 3][0:1:{x for x in range(2)}]
   |                     ^^^^^^^^^^^^^^^^^^^^^
90 | var = [1, 2, 3][0:1:{"x": x for x in range(2)}]
91 | var = [1, 2, 3][0:1:[x for x in range(2)]]
   |

RUF016 Slice in indexed access to type `list` uses type `dict comprehension` instead of an integer
  --> RUF016.py:90:21
   |
88 | var = [1, 2, 3][0:1:{"x"}]
89 | var = [1, 2, 3][0:1:{x for x in range(2)}]
90 | var = [1, 2, 3][0:1:{"x": x for x in range(2)}]
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
91 | var = [1, 2, 3][0:1:[x for x in range(2)]]
   |

RUF016 Slice in indexed access to type `list` uses type `list comprehension` instead of an integer
  --> RUF016.py:91:21
   |
89 | var = [1, 2, 3][0:1:{x for x in range(2)}]
90 | var = [1, 2, 3][0:1:{"x": x for x in range(2)}]
91 | var = [1, 2, 3][0:1:[x for x in range(2)]]
   |                     ^^^^^^^^^^^^^^^^^^^^^
92 |
93 | # Should emit for non-integer slice start and end; should emit twice with specific ranges
   |

RUF016 Slice in indexed access to type `list` uses type `str` instead of an integer
  --> RUF016.py:94:17
   |
93 | # Should emit for non-integer slice start and end; should emit twice with specific ranges
94 | var = [1, 2, 3]["x":"y"]
   |                 ^^^
95 |
96 | # Should emit once for repeated invalid access
   |

RUF016 Slice in indexed access to type `list` uses type `str` instead of an integer
  --> RUF016.py:94:21
   |
93 | # Should emit for non-integer slice start and end; should emit twice with specific ranges
94 | var = [1, 2, 3]["x":"y"]
   |                     ^^^
95 |
96 | # Should emit once for repeated invalid access
   |

RUF016 Indexed access to type `list` uses type `str` instead of an integer or slice
  --> RUF016.py:97:17
   |
96 | # Should emit once for repeated invalid access
97 | var = [1, 2, 3]["x"]["y"]["z"]
   |                 ^^^
98 |
99 | # Should emit for invalid access using lambda
   |

RUF016 Indexed access to type `list` uses type `lambda` instead of an integer or slice
   --> RUF016.py:100:17
    |
 99 | # Should emit for invalid access using lambda
100 | var = [1, 2, 3][lambda: 0]
    |                 ^^^^^^^^^
101 |
102 | # Should emit for invalid access using generator
    |

RUF016 Indexed access to type `list` uses type `generator` instead of an integer or slice
   --> RUF016.py:103:17
    |
102 | # Should emit for invalid access using generator
103 | var = [1, 2, 3][(x for x in ())]
    |                 ^^^^^^^^^^^^^^^
104 |
105 | # Cannot emit on invalid access using variable in index
    |
